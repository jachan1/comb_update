{
    "collab_server" : "",
    "contents" : "#\n# This is a Shiny web application. You can run the application by clicking\n# the 'Run App' button above.\n#\n# Find out more about building applications with Shiny here:\n#\n#    http://shiny.rstudio.com/\n#\nrequire(dplyr)\nlibrary(shiny)\nrequire(googlesheets)\n\nmkcls <- function(cond, old_ds, col_prefix){\n  new_ds <- data.frame(n=1)\n  if(sum(cond) > 0){\n    if(sum(cond) > 1){\n      totalmins30 <- sum(30 * as.numeric(old_ds$Freq[cond]) * as.numeric(old_ds$Duration[cond]) / as.numeric(old_ds$DaysPerCycle[cond]))\n      freq <- new_ds[paste0(col_prefix, \"_freq\")] <- totalmins30/30\n      dur <- new_ds[paste0(col_prefix, \"_dur\")] <- 30\n      days <- new_ds[paste0(col_prefix, \"_days\")] <- 30\n      new_ds[col_prefix] = sprintf(\"%g entries: %s\", sum(cond), paste(sprintf(\"%gx%g per %g days\", as.numeric(old_ds$Freq[cond]), as.numeric(old_ds$Duration[cond]), as.numeric(old_ds$DaysPerCycle[cond])), collapse=\", \"))\n    } else {\n      freq <- new_ds[paste0(col_prefix, \"_freq\")] <- as.numeric(old_ds$Freq[cond])\n      dur <- new_ds[paste0(col_prefix, \"_dur\")] <- as.numeric(old_ds$Duration[cond])\n      days <- new_ds[paste0(col_prefix, \"_days\")] <- as.numeric(old_ds$DaysPerCycle[cond])\n      new_ds[col_prefix] = sprintf(\"%gx%g per %g days\", freq, dur, days)\n    }\n  } else {\n    new_ds[paste0(col_prefix, c(\"_freq\", \"_dur\", \"_days\"))]  <- NA\n  }\n  new_ds\n}\n\nmkrw <- function(ds){\n  ds1 <- mkcls(ds$Mode==\"Consultation\", ds, \"consult\")\n  ds2 <- mkcls(ds$Mode==\"SpecialEd - General\", ds, \"push_in\")\n  ds3 <- mkcls(ds$Mode==\"SpecialEd - Other\" & ds$Type == \"Speech Lang 1.1\", ds, \"push_out_11\")\n  ds4 <- mkcls(ds$Mode==\"SpecialEd - Other\" & ds$Type != \"Speech Lang 1.1\", ds, \"push_out_grp\")\n  ds_out <- cbind(ds1 %>% select(-n), ds2 %>% select(-n), ds3 %>% select(-n), ds4 %>% select(-n))\n  ds_out\n}\n\n\n# Define UI for application that draws a histogram\nui <- shinyUI(fluidPage(\n  titlePanel(\"Uploading Files\"),\n  sidebarLayout(\n    sidebarPanel(\n      fileInput('file1', 'Choose CSV File',\n                accept=c('text/csv', \n                         'text/comma-separated-values,text/plain', \n                         '.csv')),\n      textInput(\"gs\", label=\"Google Sheet extension\", value=\"1Es_RC8SRopbvojrXxk_PRxyuQknG-4y9NRoY5ZmLr-s\"),\n      textInput(\"sht\", label=\"Worksheet Name\", value=\"comb\"),\n      hr(),\n      helpText(\"comb_archive_[date]: archive of old comb file\"),\n      helpText(\"comb_new: new comb file. delete old file and rename comb\")\n    ),\n    mainPanel(\n      h2('New Students Added to Comb'),\n      dataTableOutput('newstus'),\n      h2('New IEPs added to Existing Students in Comb'),\n      dataTableOutput('newieps'),\n      h2('IEPs in Comb with Different Data in New Sheet'),\n      dataTableOutput('chgieps')\n    )\n    \n    \n  )\n))\n\n# Define server logic required to draw a histogram\nserver <- shinyServer(function(input, output) {\n   \n  output$newstus <- renderDataTable({\n    \n    # input$file1 will be NULL initially. After the user selects\n    # and uploads a file, it will be a data frame with 'name',\n    # 'size', 'type', and 'datapath' columns. The 'datapath'\n    # column will contain the local filenames where the data can\n    # be found.\n    \n    inFile <- input$file1\n    \n    if (is.null(inFile))\n      return(NULL)\n    gs_auth()\n    # gs_webapp_auth_url()\n    withProgress(message=\"Working\", value=0, {\n      inc <- function(str=\"\"){\n        n=4\n        incProgress(1/n, detail = str)\n      }\n      \n      if(F) ss <- gs_url(\"https://docs.google.com/spreadsheets/d/1Es_RC8SRopbvojrXxk_PRxyuQknG-4y9NRoY5ZmLr-s\")\n      ss <- gs_url(paste0(\"https://docs.google.com/spreadsheets/d/\", input$gs))\n      inc(\"connecter to sheet\")\n      ## Read in current comb sheet and archive a copy\n      if(F) alld <- gs_read(ss, \"comb\")\n      alld <- gs_read(ss, input$sht)\n      inc(\"comb loaded\")\n      arch_sheet <- sprintf(\"comb_archived_%s\", format(Sys.Date(), \"%Y_%m_%d\"))\n      if(arch_sheet %in% ss$ws$ws_title) {\n        curs <- grep(arch_sheet, ss$ws$ws_title, value=T)\n        suffix <- max(as.numeric(gsub(paste0(arch_sheet, \"_v\"), \"\", curs)), na.rm=T)\n        arch_sheet <- paste(arch_sheet, ifelse(suffix==-Inf, 1, suffix+1), sep=\"_v\")\n      }\n      gs_ws_new(ss, ws_title=arch_sheet, input=alld, row_extent=nrow(alld))\n      inc(\"comb archived\")\n      if(F) newp <- read.csv(\"C:/Users/jy70/Downloads/QR_13769566969346085.csv\", stringsAsFactors=F)\n      newp <- read.csv(inFile$datapath, stringsAsFactors=F)\n      newp <- newp %>% rename_(lasid=grep(\"lasid\", names(newp), ignore.case = T, value=T))\n      if(!\"current\" %in% names(alld)) alld$current=1\n      if(!\"Date\" %in% class(alld$iep_end_dt)) alld$iep_end_dt=as.Date(alld$iep_end_dt, \"%m/%d/%Y\")\n      ## only keep the most recent iep noted in the new data\n      # nms <- c('lasid', 'Name', 'School', 'Grade', 'consult', 'push_in', 'push_out_11', 'push_out_grp', 'Homeroom', 'classroom', 'Homeroom_Teacher', 'teacher', 'Home_Lang', 'iep_start_dt', 'iep_end_dt', 'next_iep_review', 'next_iep_eval', paste0(rep(c(\"consult\", \"push_in\", \"push_out_11\", \"push_out_grp\"), rep(3, 4)), rep(c(\"_freq\", \"_dur\", \"_days\"), 4)))\n      \n      current_alld <- alld %>% select(lasid, current_dt=iep_end_dt) %>% arrange(lasid, desc(current_dt)) %>% filter(!duplicated(lasid))\n      rec_only <- newp %>% group_by(lasid) %>% summarise(EndDate = max(as.Date(EndDate, \"%m/%d/%Y\"))) %>% \n        left_join(newp %>% mutate(EndDate=as.Date(EndDate, \"%m/%d/%Y\")), by=c(\"lasid\", \"EndDate\")) %>% \n        left_join(current_alld, by=\"lasid\") %>% filter(is.na(current_dt) | EndDate >= current_dt) %>% select(-current_dt)\n      \n      newp_cols <- c(lasid=\"lasid\", Name=\"Name\", School=\"Name.1\", Homeroom=\"Homeroom\", Home_Lang=\"NativeLanguage\", iep_start_dt=\"StartDate\", iep_end_dt=\"EndDate\", next_iep_review=\"Next.IEP.review\", next_iep_eval=\"Next.IEP.eval\")\n      newp_cols <- newp_cols[newp_cols %in% names(rec_only)]\n      ## create text services info\n      update_d <- rec_only %>% group_by(lasid) %>% do(mkrw(.)) %>% \n        left_join(rec_only %>% filter(!duplicated(lasid)) %>% .[newp_cols] %>% setNames(names(newp_cols)), by=\"lasid\")\n     \n      ## keep only data that does not already exist in the comb file\n      ## should we also get this to update the services for subjects alread in comb?\n      new_d <- update_d %>% anti_join(alld %>% select(lasid, iep_end_dt), by=c(\"lasid\", \"iep_end_dt\")) %>% mutate(type=\"IEP\")\n      \n      # update_d %>% select(lasid, iep_end_dt, push_out_grp_new=push_out_grp, consult_new=consult, push_in_new=push_in, push_out_11_new=push_out_11) %>% \n        # right_join(alld, by=c(\"lasid\", \"iep_end_dt\"))\n      \n      alld_updates_1 <- alld %>% left_join(update_d %>% select(lasid, iep_end_dt, push_out_grp_new=push_out_grp, consult_new=consult, push_in_new=push_in, push_out_11_new=push_out_11) %>% \n                                             mutate(upd=T), by=c(\"lasid\", \"iep_end_dt\")) %>% mutate(updd=ifelse(is.na(upd), F, T)) %>% select(-upd)\n      \n      chkfxn <- function(x,y) (is.na(y) & !is.na(x)) | (!is.na(y) & is.na(x)) | (!is.na(x) & !is.na(y) & x != y)\n      \n      alld_updates <- alld_updates_1 %>% filter(current==1 & updd) %>% filter(chkfxn(push_out_grp_new, push_out_grp) | chkfxn(consult_new, consult) | chkfxn(push_in_new,push_in) | chkfxn(push_out_11_new, push_out_11)) %>%\n        mutate(push_out_grp=push_out_grp_new, consult=consult_new, push_in=push_in_new, push_out_11=push_out_11_new) %>%\n        bind_rows(alld_updates_1 %>% filter(updd) %>% mutate(chgd = chkfxn(push_out_grp_new, push_out_grp) | chkfxn(consult_new, consult) | chkfxn(push_in_new,push_in) | chkfxn(push_out_11_new, push_out_11),\n                                            current=ifelse(chgd, 0, current),\n                                            iep_end_dt_manual=ifelse(chgd, NA, Sys.Date()))) %>%\n        bind_rows(alld_updates_1 %>% filter(!updd)) %>% \n        select(-push_out_grp_new, -consult_new, -push_in_new, -push_out_11_new, -chgd, -updd)\n      \n      ## for subjects already in comb we add in new IEP info and take most info from previous comb entry\n      new_cols <- c('lasid', 'consult_freq', 'consult_dur', 'consult_days', 'push_in_freq', 'push_in_dur', 'push_in_days', 'push_out_11_freq', 'push_out_11_dur', 'push_out_11_days', 'push_out_grp_freq', 'push_out_grp_dur', 'push_out_grp_days', 'push_out_grp', 'consult', 'push_out_11', 'push_in', 'Name', 'School', 'Homeroom', 'Home_Lang', 'iep_start_dt', 'iep_end_dt', 'next_iep_eval', 'next_iep_review', 'type')\n      new_cols <- new_cols[new_cols %in% names(new_d)]\n      add_iep <- new_d %>% .[new_cols] %>% \n        inner_join(alld %>% select(lasid, Description, classroom, Grade, service_provider, prog_name), by=\"lasid\") %>% ungroup %>% mutate(current=1)\n      \n      ## for new students we can only use the new data\n      add_stu <- new_d %>% anti_join(alld, by=\"lasid\") %>% ungroup %>% mutate(current=1)\n      \n      ## combine all data and write as comb_new\n      ## go to the google sheet and delete comb and rename comb_new to comb\n      new_comb <- bind_rows(alld_updates %>% mutate(current=ifelse(current==1 & lasid %in% add_iep$lasid, 0, current)), add_iep, add_stu) %>% arrange(lasid, iep_end_dt)\n      inc(\"saving comb_new\")\n      if(\"comb_new\" %in% ss$ws$ws_title) {\n        curs <- grep(\"comb_new\", ss$ws$ws_title, value=T)\n        suffix <- max(as.numeric(substr(curs, nchar(curs), nchar(curs))), na.rm=T)\n        gs_ws_new(ss, ws_title=paste(\"comb_new\", ifelse(suffix==-Inf, 1, suffix+1), sep=\"_v\"), input=new_comb, row_extent=nrow(new_comb))\n      } else {\n        gs_ws_new(ss, ws_title=\"comb_new\", input=new_comb, row_extent=nrow(new_comb))\n      }\n      \n      ## new ieps added\n      newieps <- new_comb %>% filter(lasid %in% add_iep$lasid) %>% group_by(lasid) %>% arrange(lasid, iep_end_dt) %>% summarise(n_ieps = n(), iep_old_date=iep_end_dt[n_ieps-1], iep_new_dt=iep_end_dt[n_ieps], School=School[n_ieps], Homeroom=Homeroom[n_ieps]) %>% select(-n_ieps) %>% arrange(School)\n      \n      ## new students added\n      newstus <- add_stu %>% select(lasid, School, Homeroom) %>% arrange(School)\n      \n      ## iep updates -- should show all new ieps that have same date as old but with different services recommended\n      chgieps <- new_d %>% select( lasid, iep_end_dt, push_out_grp_new=push_out_grp, consult_new=consult, push_out_11_new=push_out_11, push_in_new=push_in) %>% \n        inner_join(alld %>% select(lasid, iep_end_dt, push_out_grp, consult, push_out_11, push_in), by=c(\"lasid\", \"iep_end_dt\"))\n      if(nrow(chgieps) > 0){\n        output$chgieps <- renderDataTable(chgieps %>% filter(push_out_grp_new!=push_out_grp | consult_new!=consult | push_out_11_new!=push_out_11 | push_in_new!=push_in))\n      } else {\n        output$chgieps <- renderDataTable(data_frame())\n      }\n      \n      output$newieps <- renderDataTable(newieps)\n      newstus\n    })\n    \n  })\n})\n\n# Run the application \nshinyApp(ui = ui, server = server)\n\n",
    "created" : 1494267072059.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "677330776",
    "id" : "F84DD15D",
    "lastKnownWriteTime" : 1494268350,
    "last_content_update" : 1494268351097,
    "path" : "//Cifs2/homedir$/BG/R/comb_update/app.R",
    "project_path" : "app.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}